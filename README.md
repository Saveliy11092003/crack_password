# CrackHash

Распределенная система, которая по MD-5 хэшу и длине пароля, возвращает пароль.

# Общая логика системы:
1. В рамках системы существует менеджер, который принимает от пользователя запрос, содержащий MD-5 хэш пароля и его максимальную длину.
2. Менеджер обрабатывает запрос и генерирует задачи в соответствии с заданным числом воркеров на поиск возможного пароля. После чего отправляет их на исполнение воркерам. 
3. Каждый воркер принимает задачу, перебирает слова в заданном диапазоне и вычисляет их хэш. Находит слова у которых хеш совпадает с заданным, и результат работы возвращает менеджеру.

# Запуск и пользовательская инструкция распределенной системы:
1. Склонировать проект - git clone https://github.com/Saveliy11092003/crack_password.git;
2. Открыть проект client-crack-password в WebStorm и запустить фронтенд по команде - npm start;
3. Открыть проекты crack-manager и worker в IntellijIdea и забилдить их с помощью команды gradle bootJar;
4. В проекте worker перейти в директорию deploy и запустить команду - docker compose -f docker-compose.yml up -d;
5. Перейти в браузере на http://localhost:3000, ввести MD-5 хэш и максимальную длину пароля, затем нажать на кнопку Crack Hash;
6. Progress bar будет показывать текущий прогресс работы распределенной системы в процентах, можно посмотреть текущий статус запроса, нажав кнопку Check Status;
7. Когда progress bar достигнет 100 процентов, по нажатию на кнопку Check Status пользователю отобразиться полный возможный список паролей.

# Реализация

Backend разрабатывался с использованием фреймворка Spring Boot, а Frontend с помощью ReactJS.

Распределенная система состоит из клиента(фронтенд приложение), менеджера и трех воркеров.

Менеджер предоставляет клиенту REST API в формате JSON для взаимодействия с ним.

Запроса на взлом хэша (слово bot23):
POST /api/hash/crack
Request body:
{
    "hash":"c139e429f817751f826f83b9f5b2fdef", 
    "maxLength": 5
}

В ответ менеджер возвращает клиенту идентификатор запроса, по которому тот сможет обратится за получением ответа.
Response body:
{
    "requestId":"730a04e6-4de9-41f9-9d5b-53b88b17afac"
}

Для получения результатов менеджер предоставляет следующее API.

GET /api/hash/status?requestId=730a04e6-4de9-41f9-9d5b-53b88b17afac

Ответ,  если запрос еще обрабатывается.
Response body:
{
    "status":"IN_PROGRESS",
    "data": null
}

Ответ,  если ответ готов.
Response body:
{
   "status":"READY",
   "data": ["abcd"]
}

Ответ,  если один из воркеров упал и ответ не полный.
Response body:
{
   "status":"ERROR",
   "data": ["abcd"]
}

В качестве алфавита менеджер использует строчные латинские буквы и цифры.
Взаимодействие между менеджером и воркерами организовано в формате JSON.
Взаимодействие с воркером организовать по протоколу HTTP с помощью Rest Template. 
Для этого в воркере реализован контроллер для обработки запросов от менеджера, принимающий запрос по следующему пути:
POST /internal/api/worker/hash/crack/task

Взаимодействие между воркером и менеджером также организовано в формате XML.
Взаимодействие с менеджером организовано по протоколу HTTP с помощью Rest Template. 
Для этого в менеджере реализован контроллер для обработки ответов от воркера по следующему пути:
PATCH /internal/api/manager/hash/crack/request

Для генерации слов на основе полученного алфавита использовалась библиотека combinatoricslib3.
Расчет диапазона слов производится на основе значений PartNumber и PartCount из запроса от менеджера, таким образом всё пространство слов делится поровну между всеми воркерами.





